---
title: "用kableExtra做牛*的表格"
author: "朱昊"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: simplex
    toc: true
    toc_depth: 2
    toc_float: true
---

突然意识到这包写了都一年了还没写过中文文档，现在给大家补上。

另外这中文版我就不发CRAN了，要看的麻烦移步这包的文档网站[http://haozhu233.github.io/kableExtra/](http://haozhu233.github.io/kableExtra/)来看吧。

（因为我基本是在自由发挥。。你们不要太去在意中文英文的不同哈。。。）

# 简介
`kableExtra`的基本目标是帮你搭建以及美化一些常用而又较为复杂的表格。这些表格有个特点，那就是用word 或者excel来做会极其简单，而要用一个编程语言去描述往往反而会让人绝望，尤其是对于一些LaTeX初心者（比如当年的我。。）。而现在，在有了这个包的帮助下，我希望你能用一种更为直觉的方式来创建你的表格，把更多的时间花在内容上。而那些排版之类的事情，就让这个包帮你打理了吧。：）

# 安装
CRAN安装`install.packages("kableExtra")`不用我说，想尝鲜可以使用开发版。
```r
# install.packages("devtools")
devtools::install_github("haozhu233/kableExtra")
```

# 第一步 
## 用`kable`生成HTML表格
首先要强调一下，`kable`这个function来自于R圈大佬谢益辉的`knitr`包。大致上说，`kable`可以生成三种格式的表格：`HTML`, `LaTeX` 和 `markdown`（默认）。`markdown`作为默认的格式完美契合`rmarkdown`本身，可却因为`markdown`表格本身功能上的限制，在很多情况下达不到我们的要求。因此，当你需要个性化你的表格时，你往往需要先让`kable`先帮你生成一个`HTML`的表格。在这份文档中，我们主要使用`mtcars`这个数据的前几列和几行数据来演示。

```{r}
library(kableExtra)
dt <- mtcars[1:5, 1:6]

kable(dt, "html")
```


注意，如果你有好几个表格要去生成，与其在每一个kable里定义格式，不如在所有的事情开始之前定义一个全局的设置。这样的话，上面的语句就只需要打`kable(dt)`就可以了。

```{r}
options(knitr.table.format = "html") 
```

## bootstrap了解一下
如果你从没听过bootstrap的话，你应该去了解一下。简单来说，bootstrap是个开源的CSS库，可以用来很方便地美化HTML页面。也因此，bootstrap在RStudio的产品中被大量使用。你用rmarkdown和shiny生成出来的HTML文档和app都有加载。而这个包的HTML部分也提供了一些借口方便你快速实现一些bootstrap风的表格。

```{r}
dt %>%
  kable("html") %>%
  kable_styling()
```

# 表格整体风格
`kable_styling`提供了几种其他的方式来定制表格的整体风格。

## Bootstrap的表格`class`
如果你熟悉bootstrap，那么以下这些css `class`对你一定不陌生：`striped`, `bordered`, `hover`, `condensed` 以及 `responsive`. 如果你不熟悉，你可以看看 [这里](http://getbootstrap.com/css/#tables)。你可以通过`kable_styling`快速地把这些样式应用到你的表格里。比如，下面这个例子就是给表格加上斑马纹和悬浮效果。

```{r}
kable(dt, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

有些人觉得默认的bootstrap表格每行都太高了，这时候用上`condensed`会让内容显得更紧凑。
```{r}
kable(dt, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

`responsive`这选项可以让表格样式随屏幕宽度变化，更适合手机屏。
```{r}
kable(dt, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

## “为啥我的表格这么宽啊？”
“为啥我的表格这么宽”是一个`rmarkdown`新人常见问题。原因是`bootstrap`把宽度统一订成了100%的容器宽。设计`bootstrap`的人原来想让你用他们的grid system来控制表格的宽度，可是当你在写`rmarkdown`的时候，难道还想即兴来定义一串`<div>`？解决办法如下。
```{r}
kable(dt, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

## 表格位置
表格在页面中位置也是排版很重要的一块。注意，这只有在表格不是全屏宽的时候才有用（这是当然的啦。
```{r}
kable(dt, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

除了常见的左中右，你还可以选择`float_left`和`float_right`。
```{r}
kable(dt, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "float_right")
```
从小丘西行百二十步，隔篁竹，闻水声，如鸣佩环，心乐之。伐竹取道，下见小潭，水尤清洌。全石以为底，近岸，卷石底以出，为坻，为屿，为嵁，为岩。青树翠蔓，蒙络摇缀，参差披拂。

潭中鱼可百许头，皆若空游无所依。日光下澈，影布石上，佁然不动；俶尔远逝，往来翕忽，似与游者相乐。

潭西南而望，斗折蛇行，明灭可见。其岸势犬牙差互，不可知其源。

坐潭上，四面竹树环合，寂寥无人，凄神寒骨，悄怆幽邃。以其境过清，不可久居，乃记之而去。

同游者，吴武陵，龚古，余弟宗玄。隶而从者，崔氏二小生：曰恕己，曰奉壹。


## 字体大小
如题，当你的表格过大时，你可以调调字体大小。
```{r}
kable(dt, "html") %>%
  kable_styling(bootstrap_options = "striped", font_size = 7)
```

# 列与行的格式
## 列
`column_spec`如其名，可以帮你定义某一列的样式，比如宽度啊，字体颜色啊，加粗，斜体等。列的宽度其实尤为重要，这样你表格的样式不会被一串巨长的文字打乱。

```{r}
text_tbl <- data.frame(
  Items = c("Item 1", "Item 2", "Item 3"),
  Features = c(
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin vehicula tempor ex. Morbi malesuada sagittis turpis, at venenatis nisl luctus a. ",
    "In eu urna at magna luctus rhoncus quis in nisl. Fusce in velit varius, posuere risus et, cursus augue. Duis eleifend aliquam ante, a aliquet ex tincidunt in. ", 
    "Vivamus venenatis egestas eros ut tempus. Vivamus id est nisi. Aliquam molestie erat et sollicitudin venenatis. In ac lacus at velit scelerisque mattis. "
  )
)

kable(text_tbl, "html") %>%
  kable_styling(full_width = F) %>%
  column_spec(1, bold = T, border_right = T) %>%
  column_spec(2, width = "30em", background = "yellow")
```


## 行
`row_spec`和`column_spec`差不多，除了没有列宽这样的东西。注意，当你数第几行的时候，你不需要考虑表头和你通过`group_rows`添加的那些行，就数那些原生的“内容”行就行。

```{r}
kable(dt, "html") %>%
  kable_styling("striped", full_width = F) %>%
  column_spec(5:7, bold = T) %>%
  row_spec(3:5, bold = T, color = "white", background = "#D7261E")
```

### 表头的那行
只需要说`row_spec(0, ...)`就可以了。
```{r}
kable(dt, format = "html") %>%
  kable_styling("striped", full_width = F) %>%
  row_spec(0, angle = -45)
```

# 格子的格式
`cell_spec` 和之前说的两个`spec`不一样，你应该在把你的数据放进`kable`之前使用它。就像如下的例子，`cell_spec`可以很轻易的用在`dplyr`的pipeline里。注意，因为你用`cell_spec`生成的是直接的`HTML`和`LaTeX`，你需要在`kable`里加上`escape = FALSE`。同时，你需要告诉`cell_spec`你到底需要`HTML`还是`LaTeX`。如果你需要大量使用的话，使用全局格式设定会让你好过很多。再说一遍，`options(knitr.table.format = "latex")`。

## `cell_spec`和`ifelse`
`cell_spec`和`ifelse`结合会让表格里的数据的可视度一下子高很多。
```{r, message=FALSE, warning=FALSE}
library(dplyr)
mtcars[1:10, 1:2] %>%
  mutate(
    car = row.names(.),
    # You don't need format = "html" if you have ever defined options(knitr.table.format)
    mpg = cell_spec(mpg, "html", color = ifelse(mpg > 20, "red", "blue")),
    cyl = cell_spec(cyl, "html", color = "white", align = "c", angle = 45, 
                    background = factor(cyl, c(4, 6, 8), 
                                        c("#666666", "#999999", "#BBBBBB")))
  ) %>%
  select(car, mpg, cyl) %>%
  kable("html", escape = F) %>%
  kable_styling("striped", full_width = F)
```

## 给你的表格加上Viridis Color
这包还带了几个`cell_spec`的辅助型方程，包括 `spec_color`, `spec_font_size` 和 `spec_angle`. 他们可以帮你把数据变成相应的颜色，字体大小和角度。其中最有意思的是那个颜色，这里用了[viridis color](https://CRAN.R-project.org/package=viridisLite)这个色板. 合理使用的话几乎可以在表格里画热图。

```{r}
iris[1:10, ] %>%
  mutate_if(is.numeric, function(x) {
    cell_spec(x, "html", bold = T, 
              color = spec_color(x, end = 0.9),
              font_size = spec_font_size(x))
  }) %>%
  mutate(Species = cell_spec(
    Species, "html", color = "white", bold = T,
    background = spec_color(1:10, end = 0.9, option = "A", direction = -1)
  )) %>%
  kable("html", escape = F, align = "c") %>%
  kable_styling("striped", full_width = F)
```


## 普通文本的格式
其实你也可以用`cell_spec`或者`text_spec`去定义普通文字的样式。 

```{r}
sometext <- strsplit("人群中突然钻出一个光头", "")[[1]]
text_formatted <- paste(
  text_spec(sometext, "html", color = spec_color(1:length(sometext), end = 0.9),
            font_size = spec_font_size(1:length(sometext), begin = 5, end = 20)),
  collapse = "")

```
`r text_formatted`

## Tooltip 悬浮提示框
你可以通过`cell_spec`相对简单地添加悬浮提示框. 举个例子，`text_spec("tooltip", color = "red", tooltip = "Hello World")` 会生成 `r text_spec("Hover over me", color = "red", tooltip = "Hello World")`。注意HTML原生的提示框非常慢，你可能会想用`bootstrap`的javascript版的。如果你想这么做的话，你需要把接下来的这段代码放在你的rmarkdown文本的任何地方。需要注意的是，如果你和这个文档一样使用了这种目录在侧面的格式，你就没办法使用这个功能。原因在于这个和`jqueryui`的`tooltip`互相冲突。这种情况下，你可能会想试试我下面说的`popover`。这两个差不多。

```
<script>
$(document).ready(function(){
    $('[data-toggle="tooltip"]').tooltip(); 
});
</script>
```

## Popover Message 有头的悬浮弹出提示框
和之前一样的设定，区别在于你可以给`popover`的小框加一个标题。不加的话，和上面的功能基本一样。

```
<script>
$(document).ready(function(){
    $('[data-toggle="popover"]').popover(); 
});
</script>
```

<script>
$(document).ready(function(){
    $('[data-toggle="popover"]').popover(); 
});
</script>

```{r}
popover_dt <- data.frame(
  position = c("top", "bottom", "right", "left"),
  stringsAsFactors = FALSE
)
popover_dt$`Hover over these items` <- cell_spec(
  paste("Message on", popover_dt$position), # Cell texts
  popover = spec_popover(
    content = popover_dt$position,
    title = NULL,                           # title will add a Title Panel on top
    position = popover_dt$position
  ))
kable(popover_dt, "html", escape = FALSE) %>%
  kable_styling("striped", full_width = FALSE)
```

## 链接
你可以给文字添加一个链接`text_spec("Google", link = "https://google.com")`: `r text_spec("Google", link = "https://google.com")`。这里有一个利用加链接让`popover`悬浮框本来的文本更加明显的小技巧 `text_spec("Hover on me", link = "javascript:void(0)", popover = "Hello")`: `r text_spec("Hover on me", link = "javascript:void(0)", popover = "Hello")`

## 同时使用`kableExtra`和`formattable` 
如果你也喜欢任坤大佬的`formattable`的话，你其实可以将`formattable`和`kableExtra`用在一起，灰常酷炫。
```{r, message = FALSE, warning=FALSE}
library(formattable)
mtcars[1:5, 1:4] %>%
  mutate(
    car = row.names(.),
    mpg = color_tile("white", "orange")(mpg),
    cyl = cell_spec(cyl, "html", angle = (1:5)*60, 
                    background = "red", color = "white", align = "center"),
    disp = ifelse(disp > 200,
                  cell_spec(disp, "html", color = "red", bold = T),
                  cell_spec(disp, "html", color = "green", italic = T)),
    hp = color_bar("lightgreen")(hp)
  ) %>%
  select(car, everything()) %>%
  kable("html", escape = F) %>%
  kable_styling("hover", full_width = F) %>%
  column_spec(5, width = "3cm") %>%
  add_header_above(c(" ", "Hello" = 2, "World" = 2))
```


# 行组和列组
## 列组
我们在Word里做表格时，要想表示两个列同属一个类，我们会在这两列的上面再加一行，画条横线，写上名字。基本上`add_header_above`就是做这事的。在使用这个方程时，你需要给他一个**`named vector`**（划重点）。这个`named vector`的本身是column span，而具体的文字则在names里（没看懂我在说啥的，请参考下面的例子）。这样的设计主要是为了方便。
```{r}
kable(dt, "html") %>%
  kable_styling("striped") %>%
  add_header_above(c(" " = 1, "Group 1" = 2, "Group 2" = 2, "Group 3" = 2))
```

事实上，你甚至可以一层一层继续往上加下去。
```{r}
kable(dt, "html") %>%
  kable_styling(c("striped", "bordered")) %>%
  add_header_above(c(" ", "Group 1" = 2, "Group 2" = 2, "Group 3" = 2)) %>%
  add_header_above(c(" ", "Group 4" = 4, "Group 5" = 2)) %>%
  add_header_above(c(" ", "Group 6" = 6))
```

## Group rows via labeling
Sometimes we want a few rows of the table being grouped together. They might be items under the same topic (e.g., animals in one species) or just different data groups for a categorical variable (e.g., age < 40, age > 40). With the new function `group_rows()` in `kableExtra`, this kind of task can be completed in one line. Please see the example below. Note that when you count for the start/end rows of the group, you don't need to count for the header rows nor other group label rows. You only need to think about the row numbers in the "original R dataframe".
```{r}
kable(mtcars[1:10, 1:6], "html", caption = "Group Rows") %>%
  kable_styling("striped", full_width = F) %>%
  group_rows("Group 1", 4, 7) %>%
  group_rows("Group 2", 8, 10)
```

Another way to use `group_rows` is to provide an grouping index, similar with `add_header_above()`. This feature is only available in kableExtra > 0.5.2.
```{r, eval = F}
# Not evaluated. This example generates the same table as above.
kable(mtcars[1:10, 1:6], "html", caption = "Group Rows") %>%
  kable_styling("striped", full_width = F) %>%
  group_rows(index = c(" " = 3, "Group 1" = 4, "Group 2" = 3))
```

For advanced users, you can even define your own css for the group labeling.
```{r}
kable(dt, "html") %>%
  kable_styling("striped", full_width = F) %>%
  group_rows("Group 1", 3, 5, label_row_css = "background-color: #666; color: #fff;")
```

## Row indentation
Unlike `group_rows()`, which will insert a labeling row, sometimes we want to list a few sub groups under a total one. In that case, `add_indent()` is probably more apporiate. 
For advanced users, you can even define your own css for the group labeling.
```{r}
kable(dt, "html") %>%
  kable_styling("striped", full_width = F) %>%
  add_indent(c(1, 3, 5))
```

## Group rows via multi-row cell
Function `group_rows` is great for showing simple structural information on rows but sometimes people may need to show structural information with multiple layers. When it happens, you may consider to use `collapse_rows` instead, which will put repeating cells in columns into multi-row cells. 

```{r}
collapse_rows_dt <- data.frame(C1 = c(rep("a", 10), rep("b", 5)),
                 C2 = c(rep("c", 7), rep("d", 3), rep("c", 2), rep("d", 3)),
                 C3 = 1:15,
                 C4 = sample(c(0,1), 15, replace = TRUE))
kable(collapse_rows_dt, "html", align = "c") %>%
  kable_styling(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1:2)
```

# Table Footnote

> Now it's recommended to use the new `footnote` function instead of `add_footnote` to make table footnotes. 

Documentations for `add_footnote` can be found [here](http://haozhu233.github.io/kableExtra/legacy_features#add_footnote).

There are four notation systems in `footnote`, namely `general`, `number`, `alphabet` and `symbol`. The last three types of footnotes will be labeled with corresponding marks while `general` won't be labeled. You can pick any one of these systems or choose to display them all for fulfill the APA table footnotes requirements. 
```{r}
kable(dt, "html", align = "c") %>%
  kable_styling(full_width = F) %>%
  footnote(general = "Here is a general comments of the table. ",
           number = c("Footnote 1; ", "Footnote 2; "),
           alphabet = c("Footnote A; ", "Footnote B; "),
           symbol = c("Footnote Symbol 1; ", "Footnote Symbol 2")
           )
```

You can also specify title for each category by using the `***_title` arguments. Default value for `general_title` is "Note: " and "" for the rest three. You can also change the order using `footnote_order`. You can even display footnote as chunk texts (default is as a list) using `footnote_as_chunk`.

```{r}
kable(dt, "html", align = "c") %>%
  kable_styling(full_width = F) %>%
  footnote(general = "Here is a general comments of the table. ",
           number = c("Footnote 1; ", "Footnote 2; "),
           alphabet = c("Footnote A; ", "Footnote B; "),
           symbol = c("Footnote Symbol 1; ", "Footnote Symbol 2"),
           general_title = "General: ", number_title = "Type I: ",
           alphabet_title = "Type II: ", symbol_title = "Type III: ",
           footnote_as_chunk = T
           )
```

If you need to add footnote marks in table, you need to do it manually (no fancy) using `footnote_mark_***()`. Remember that similar with `cell_spec`, you need to tell this function whether you want it to do it in `HTML` (default) or `LaTeX`. You can set it for all using the `knitr.table.format` global option. ALso, if you have ever use `footnote_mark_***()`, you need to put `escape = F` in your `kable` function to avoid escaping of special characters. 

```{r}
dt_footnote <- dt
names(dt_footnote)[2] <- paste0(names(dt_footnote)[2], 
                                footnote_marker_symbol(1))
row.names(dt_footnote)[4] <- paste0(row.names(dt_footnote)[4], 
                                footnote_marker_alphabet(1))
kable(dt_footnote, "html", align = "c", 
      # Remember this escape = F
      escape = F) %>%
  kable_styling(full_width = F) %>%
  footnote(alphabet = "Footnote A; ",
           symbol = "Footnote Symbol 1; ",
           alphabet_title = "Type II: ", symbol_title = "Type III: ",
           footnote_as_chunk = T)
```

# HTML Only Features
## Scroll box
If you have a huge table and you don't want to reduce the font size to unreadable, you may want to put your HTML table in a scroll box, of which users can pick the part they like to read. Note that scroll box isn't printer friendly, so be aware of that when you use this feature. 

When you use `scroll_box`, you can specify either `height` or `width`. When you specify `height`, you will get a vertically scrollable box and vice versa. If you specify both, you will get a two-way scrollable box. 

```{r}
kable(cbind(mtcars, mtcars), "html") %>%
  kable_styling() %>%
  scroll_box(width = "500px", height = "200px")
```
